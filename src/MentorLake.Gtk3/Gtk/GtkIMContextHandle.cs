namespace MentorLake.Gtk;

/// <summary>
/// <para>
/// #GtkIMContext defines the interface for GTK+ input methods. An input method
/// is used by GTK+ text input widgets like #GtkEntry to map from key events to
/// Unicode character strings.
/// </para>
/// <para>
/// The default input method can be set programmatically via the
/// #GtkSettings:gtk-im-module GtkSettings property. Alternatively, you may set
/// the GTK_IM_MODULE environment variable as documented in
/// [Running GTK+ Applications][gtk-running].
/// </para>
/// <para>
/// The #GtkEntry #GtkEntry:im-module and #GtkTextView #GtkTextView:im-module
/// properties may also be used to set input methods for specific widget
/// instances. For instance, a certain entry widget might be expected to contain
/// certain characters which would be easier to input with a certain input
/// method.
/// </para>
/// <para>
/// An input method may consume multiple key events in sequence and finally
/// output the composed result. This is called preediting, and an input method
/// may provide feedback about this process by displaying the intermediate
/// composition states as preedit text. For instance, the default GTK+ input
/// method implements the input of arbitrary Unicode code points by holding down
/// the Control and Shift keys and then typing “U” followed by the hexadecimal
/// digits of the code point.  When releasing the Control and Shift keys,
/// preediting ends and the character is inserted as text. Ctrl+Shift+u20AC for
/// example results in the € sign.
/// </para>
/// <para>
/// Additional input methods can be made available for use by GTK+ widgets as
/// loadable modules. An input method module is a small shared library which
/// implements a subclass of #GtkIMContext or #GtkIMContextSimple and exports
/// these four functions:
/// </para>
/// <code>
/// void im_module_init(GTypeModule *module);
/// void im_module_init(GTypeModule *module);
/// </code>
/// <para>
/// implements the input method by means of g_type_module_register_type(). Note
/// that g_type_register_static() cannot be used as the type needs to be
/// registered dynamically.
/// </para>
/// <code>
/// void im_module_exit(void);
/// void im_module_exit(void);
/// </code>
/// 
/// <code>
/// void im_module_list(const GtkIMContextInfo ***contexts, int *n_contexts)
/// void im_module_list(const GtkIMContextInfo ***contexts, int *n_contexts)
/// {
///   *contexts = info_list;
///   *n_contexts = G_N_ELEMENTS (info_list);
/// }
/// </code>
/// <para>
/// example implementation above shows a common solution and simply returns a
/// pointer to statically defined array of #GtkIMContextInfo items for each
/// provided input method.
/// </para>
/// <code>
/// GtkIMContext * im_module_create(const gchar *context_id);
/// GtkIMContext * im_module_create(const gchar *context_id);
/// </code>
/// <para>
/// #GtkIMContext subclass identified by @context_id. The context ID is the same
/// as specified in the #GtkIMContextInfo array returned by im_module_list().
/// </para>
/// <para>
/// After a new loadable input method module has been installed on the system,
/// the configuration file `gtk.immodules` needs to be
/// regenerated by [gtk-query-immodules-3.0][gtk-query-immodules-3.0],
/// in order for the new input method to become available to GTK+ applications.
/// </para>
/// </summary>

public class GtkIMContextHandle : GObjectHandle
{
}
public static class GtkIMContextHandleSignalExtensions
{
/// <summary>
/// <para>
/// The ::commit signal is emitted when a complete input sequence
/// has been entered by the user. This can be a single character
/// immediately after a key press or the final result of preediting.
/// </para>
/// </summary>

	public static IObservable<GtkIMContextHandleSignalStructs.CommitSignal> Signal_Commit(this GtkIMContextHandle instance, GConnectFlags connectFlags = GConnectFlags.G_CONNECT_AFTER)
	{
		return Observable.Create((IObserver<GtkIMContextHandleSignalStructs.CommitSignal> obs) =>
		{
			GtkIMContextHandleSignalDelegates.commit handler = ( MentorLake.Gtk.GtkIMContextHandle self,  string str,  IntPtr user_data) =>
			{
				

				var signalStruct = new GtkIMContextHandleSignalStructs.CommitSignal()
				{
					Self = self, Str = str, UserData = user_data
				};

				obs.OnNext(signalStruct);
				return ;
			};

			var gcHandle = System.Runtime.InteropServices.GCHandle.Alloc(handler);
			var handlerId = GObjectGlobalFunctions.SignalConnectData(instance, "commit", Marshal.GetFunctionPointerForDelegate(handler), IntPtr.Zero, null, connectFlags);

			return Disposable.Create(() =>
			{
				GObjectGlobalFunctions.SignalHandlerDisconnect(instance, handlerId);
				obs.OnCompleted();
				gcHandle.Free();
			});
		});
	}
/// <summary>
/// <para>
/// The ::delete-surrounding signal is emitted when the input method
/// needs to delete all or part of the context surrounding the cursor.
/// </para>
/// </summary>

	public static IObservable<GtkIMContextHandleSignalStructs.DeleteSurroundingSignal> Signal_DeleteSurrounding(this GtkIMContextHandle instance, GConnectFlags connectFlags = GConnectFlags.G_CONNECT_AFTER)
	{
		return Observable.Create((IObserver<GtkIMContextHandleSignalStructs.DeleteSurroundingSignal> obs) =>
		{
			GtkIMContextHandleSignalDelegates.delete_surrounding handler = ( MentorLake.Gtk.GtkIMContextHandle self,  int offset,  int n_chars,  IntPtr user_data) =>
			{
				

				var signalStruct = new GtkIMContextHandleSignalStructs.DeleteSurroundingSignal()
				{
					Self = self, Offset = offset, NChars = n_chars, UserData = user_data
				};

				obs.OnNext(signalStruct);
				return signalStruct.ReturnValue;
			};

			var gcHandle = System.Runtime.InteropServices.GCHandle.Alloc(handler);
			var handlerId = GObjectGlobalFunctions.SignalConnectData(instance, "delete-surrounding", Marshal.GetFunctionPointerForDelegate(handler), IntPtr.Zero, null, connectFlags);

			return Disposable.Create(() =>
			{
				GObjectGlobalFunctions.SignalHandlerDisconnect(instance, handlerId);
				obs.OnCompleted();
				gcHandle.Free();
			});
		});
	}
/// <summary>
/// <para>
/// The ::preedit-changed signal is emitted whenever the preedit sequence
/// currently being entered has changed.  It is also emitted at the end of
/// a preedit sequence, in which case
/// gtk_im_context_get_preedit_string() returns the empty string.
/// </para>
/// </summary>

	public static IObservable<GtkIMContextHandleSignalStructs.PreeditChangedSignal> Signal_PreeditChanged(this GtkIMContextHandle instance, GConnectFlags connectFlags = GConnectFlags.G_CONNECT_AFTER)
	{
		return Observable.Create((IObserver<GtkIMContextHandleSignalStructs.PreeditChangedSignal> obs) =>
		{
			GtkIMContextHandleSignalDelegates.preedit_changed handler = ( MentorLake.Gtk.GtkIMContextHandle self,  IntPtr user_data) =>
			{
				

				var signalStruct = new GtkIMContextHandleSignalStructs.PreeditChangedSignal()
				{
					Self = self, UserData = user_data
				};

				obs.OnNext(signalStruct);
				return ;
			};

			var gcHandle = System.Runtime.InteropServices.GCHandle.Alloc(handler);
			var handlerId = GObjectGlobalFunctions.SignalConnectData(instance, "preedit-changed", Marshal.GetFunctionPointerForDelegate(handler), IntPtr.Zero, null, connectFlags);

			return Disposable.Create(() =>
			{
				GObjectGlobalFunctions.SignalHandlerDisconnect(instance, handlerId);
				obs.OnCompleted();
				gcHandle.Free();
			});
		});
	}
/// <summary>
/// <para>
/// The ::preedit-end signal is emitted when a preediting sequence
/// has been completed or canceled.
/// </para>
/// </summary>

	public static IObservable<GtkIMContextHandleSignalStructs.PreeditEndSignal> Signal_PreeditEnd(this GtkIMContextHandle instance, GConnectFlags connectFlags = GConnectFlags.G_CONNECT_AFTER)
	{
		return Observable.Create((IObserver<GtkIMContextHandleSignalStructs.PreeditEndSignal> obs) =>
		{
			GtkIMContextHandleSignalDelegates.preedit_end handler = ( MentorLake.Gtk.GtkIMContextHandle self,  IntPtr user_data) =>
			{
				

				var signalStruct = new GtkIMContextHandleSignalStructs.PreeditEndSignal()
				{
					Self = self, UserData = user_data
				};

				obs.OnNext(signalStruct);
				return ;
			};

			var gcHandle = System.Runtime.InteropServices.GCHandle.Alloc(handler);
			var handlerId = GObjectGlobalFunctions.SignalConnectData(instance, "preedit-end", Marshal.GetFunctionPointerForDelegate(handler), IntPtr.Zero, null, connectFlags);

			return Disposable.Create(() =>
			{
				GObjectGlobalFunctions.SignalHandlerDisconnect(instance, handlerId);
				obs.OnCompleted();
				gcHandle.Free();
			});
		});
	}
/// <summary>
/// <para>
/// The ::preedit-start signal is emitted when a new preediting sequence
/// starts.
/// </para>
/// </summary>

	public static IObservable<GtkIMContextHandleSignalStructs.PreeditStartSignal> Signal_PreeditStart(this GtkIMContextHandle instance, GConnectFlags connectFlags = GConnectFlags.G_CONNECT_AFTER)
	{
		return Observable.Create((IObserver<GtkIMContextHandleSignalStructs.PreeditStartSignal> obs) =>
		{
			GtkIMContextHandleSignalDelegates.preedit_start handler = ( MentorLake.Gtk.GtkIMContextHandle self,  IntPtr user_data) =>
			{
				

				var signalStruct = new GtkIMContextHandleSignalStructs.PreeditStartSignal()
				{
					Self = self, UserData = user_data
				};

				obs.OnNext(signalStruct);
				return ;
			};

			var gcHandle = System.Runtime.InteropServices.GCHandle.Alloc(handler);
			var handlerId = GObjectGlobalFunctions.SignalConnectData(instance, "preedit-start", Marshal.GetFunctionPointerForDelegate(handler), IntPtr.Zero, null, connectFlags);

			return Disposable.Create(() =>
			{
				GObjectGlobalFunctions.SignalHandlerDisconnect(instance, handlerId);
				obs.OnCompleted();
				gcHandle.Free();
			});
		});
	}
/// <summary>
/// <para>
/// The ::retrieve-surrounding signal is emitted when the input method
/// requires the context surrounding the cursor.  The callback should set
/// the input method surrounding context by calling the
/// gtk_im_context_set_surrounding() method.
/// </para>
/// </summary>

	public static IObservable<GtkIMContextHandleSignalStructs.RetrieveSurroundingSignal> Signal_RetrieveSurrounding(this GtkIMContextHandle instance, GConnectFlags connectFlags = GConnectFlags.G_CONNECT_AFTER)
	{
		return Observable.Create((IObserver<GtkIMContextHandleSignalStructs.RetrieveSurroundingSignal> obs) =>
		{
			GtkIMContextHandleSignalDelegates.retrieve_surrounding handler = ( MentorLake.Gtk.GtkIMContextHandle self,  IntPtr user_data) =>
			{
				

				var signalStruct = new GtkIMContextHandleSignalStructs.RetrieveSurroundingSignal()
				{
					Self = self, UserData = user_data
				};

				obs.OnNext(signalStruct);
				return signalStruct.ReturnValue;
			};

			var gcHandle = System.Runtime.InteropServices.GCHandle.Alloc(handler);
			var handlerId = GObjectGlobalFunctions.SignalConnectData(instance, "retrieve-surrounding", Marshal.GetFunctionPointerForDelegate(handler), IntPtr.Zero, null, connectFlags);

			return Disposable.Create(() =>
			{
				GObjectGlobalFunctions.SignalHandlerDisconnect(instance, handlerId);
				obs.OnCompleted();
				gcHandle.Free();
			});
		});
	}
}

public static class GtkIMContextHandleSignalStructs
{

public class CommitSignal
{

	public MentorLake.Gtk.GtkIMContextHandle Self;
/// <summary>
/// <para>
/// the completed character(s) entered by the user
/// </para>
/// </summary>

	public string Str;

	public IntPtr UserData;
}

public class DeleteSurroundingSignal
{

	public MentorLake.Gtk.GtkIMContextHandle Self;
/// <summary>
/// <para>
/// the character offset from the cursor position of the text
///           to be deleted. A negative value indicates a position before
///           the cursor.
/// </para>
/// </summary>

	public int Offset;
/// <summary>
/// <para>
/// the number of characters to be deleted
/// </para>
/// </summary>

	public int NChars;

	public IntPtr UserData;
/// <summary>
/// <para>
/// %TRUE if the signal was handled.
/// </para>
/// </summary>

	public bool ReturnValue;
}

public class PreeditChangedSignal
{

	public MentorLake.Gtk.GtkIMContextHandle Self;

	public IntPtr UserData;
}

public class PreeditEndSignal
{

	public MentorLake.Gtk.GtkIMContextHandle Self;

	public IntPtr UserData;
}

public class PreeditStartSignal
{

	public MentorLake.Gtk.GtkIMContextHandle Self;

	public IntPtr UserData;
}

public class RetrieveSurroundingSignal
{

	public MentorLake.Gtk.GtkIMContextHandle Self;

	public IntPtr UserData;
/// <summary>
/// <para>
/// %TRUE if the signal was handled.
/// </para>
/// </summary>

	public bool ReturnValue;
}
}

public static class GtkIMContextHandleSignalDelegates
{

/// <summary>
/// <para>
/// The ::commit signal is emitted when a complete input sequence
/// has been entered by the user. This can be a single character
/// immediately after a key press or the final result of preediting.
/// </para>
/// </summary>

/// <param name="self">
/// </param>
/// <param name="str">
/// the completed character(s) entered by the user
/// </param>
/// <param name="user_data">
/// </param>

[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
public delegate void commit([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(DelegateSafeHandleMarshaller<MentorLake.Gtk.GtkIMContextHandle>))] MentorLake.Gtk.GtkIMContextHandle self, string str, IntPtr user_data);


/// <summary>
/// <para>
/// The ::delete-surrounding signal is emitted when the input method
/// needs to delete all or part of the context surrounding the cursor.
/// </para>
/// </summary>

/// <param name="self">
/// </param>
/// <param name="offset">
/// the character offset from the cursor position of the text
///           to be deleted. A negative value indicates a position before
///           the cursor.
/// </param>
/// <param name="n_chars">
/// the number of characters to be deleted
/// </param>
/// <param name="user_data">
/// </param>
/// <return>
/// %TRUE if the signal was handled.
/// </return>

[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
public delegate bool delete_surrounding([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(DelegateSafeHandleMarshaller<MentorLake.Gtk.GtkIMContextHandle>))] MentorLake.Gtk.GtkIMContextHandle self, int offset, int n_chars, IntPtr user_data);


/// <summary>
/// <para>
/// The ::preedit-changed signal is emitted whenever the preedit sequence
/// currently being entered has changed.  It is also emitted at the end of
/// a preedit sequence, in which case
/// gtk_im_context_get_preedit_string() returns the empty string.
/// </para>
/// </summary>

/// <param name="self">
/// </param>
/// <param name="user_data">
/// </param>

[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
public delegate void preedit_changed([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(DelegateSafeHandleMarshaller<MentorLake.Gtk.GtkIMContextHandle>))] MentorLake.Gtk.GtkIMContextHandle self, IntPtr user_data);


/// <summary>
/// <para>
/// The ::preedit-end signal is emitted when a preediting sequence
/// has been completed or canceled.
/// </para>
/// </summary>

/// <param name="self">
/// </param>
/// <param name="user_data">
/// </param>

[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
public delegate void preedit_end([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(DelegateSafeHandleMarshaller<MentorLake.Gtk.GtkIMContextHandle>))] MentorLake.Gtk.GtkIMContextHandle self, IntPtr user_data);


/// <summary>
/// <para>
/// The ::preedit-start signal is emitted when a new preediting sequence
/// starts.
/// </para>
/// </summary>

/// <param name="self">
/// </param>
/// <param name="user_data">
/// </param>

[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
public delegate void preedit_start([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(DelegateSafeHandleMarshaller<MentorLake.Gtk.GtkIMContextHandle>))] MentorLake.Gtk.GtkIMContextHandle self, IntPtr user_data);


/// <summary>
/// <para>
/// The ::retrieve-surrounding signal is emitted when the input method
/// requires the context surrounding the cursor.  The callback should set
/// the input method surrounding context by calling the
/// gtk_im_context_set_surrounding() method.
/// </para>
/// </summary>

/// <param name="self">
/// </param>
/// <param name="user_data">
/// </param>
/// <return>
/// %TRUE if the signal was handled.
/// </return>

[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
public delegate bool retrieve_surrounding([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(DelegateSafeHandleMarshaller<MentorLake.Gtk.GtkIMContextHandle>))] MentorLake.Gtk.GtkIMContextHandle self, IntPtr user_data);

}


public static class GtkIMContextHandleExtensions
{
/// <summary>
/// <para>
/// Asks the widget that the input context is attached to to delete
/// characters around the cursor position by emitting the
/// GtkIMContext::delete_surrounding signal. Note that @offset and @n_chars
/// are in characters not in bytes which differs from the usage other
/// places in #GtkIMContext.
/// </para>
/// <para>
/// In order to use this function, you should first call
/// gtk_im_context_get_surrounding() to get the current context, and
/// call this function immediately afterwards to make sure that you
/// know what you are deleting. You should also account for the fact
/// that even if the signal was handled, the input context might not
/// have deleted all the characters that were requested to be deleted.
/// </para>
/// <para>
/// This function is used by an input method that wants to make
/// subsitutions in the existing text in response to new input. It is
/// not useful for applications.
/// </para>
/// </summary>

/// <param name="context">
/// a #GtkIMContext
/// </param>
/// <param name="offset">
/// offset from cursor position in chars;
///    a negative value means start before the cursor.
/// </param>
/// <param name="n_chars">
/// number of characters to delete.
/// </param>
/// <return>
/// %TRUE if the signal was handled.
/// </return>

	public static bool DeleteSurrounding(this MentorLake.Gtk.GtkIMContextHandle context, int offset, int n_chars)
	{
		if (context.IsInvalid) throw new Exception("Invalid handle (GtkIMContextHandle)");
		return GtkIMContextHandleExterns.gtk_im_context_delete_surrounding(context, offset, n_chars);
	}

/// <summary>
/// <para>
/// Allow an input method to internally handle key press and release
/// events. If this function returns %TRUE, then no further processing
/// should be done for this key event.
/// </para>
/// </summary>

/// <param name="context">
/// a #GtkIMContext
/// </param>
/// <param name="@event">
/// the key event
/// </param>
/// <return>
/// %TRUE if the input method handled the key event.
/// </return>

	public static bool FilterKeypress(this MentorLake.Gtk.GtkIMContextHandle context, MentorLake.Gdk.GdkEventKeyHandle @event)
	{
		if (context.IsInvalid) throw new Exception("Invalid handle (GtkIMContextHandle)");
		return GtkIMContextHandleExterns.gtk_im_context_filter_keypress(context, @event);
	}

/// <summary>
/// <para>
/// Notify the input method that the widget to which this
/// input context corresponds has gained focus. The input method
/// may, for example, change the displayed feedback to reflect
/// this change.
/// </para>
/// </summary>

/// <param name="context">
/// a #GtkIMContext
/// </param>

	public static T FocusIn<T>(this T context) where T : GtkIMContextHandle
	{
		if (context.IsInvalid) throw new Exception("Invalid handle (GtkIMContextHandle)");
		GtkIMContextHandleExterns.gtk_im_context_focus_in(context);
		return context;
	}

/// <summary>
/// <para>
/// Notify the input method that the widget to which this
/// input context corresponds has lost focus. The input method
/// may, for example, change the displayed feedback or reset the contexts
/// state to reflect this change.
/// </para>
/// </summary>

/// <param name="context">
/// a #GtkIMContext
/// </param>

	public static T FocusOut<T>(this T context) where T : GtkIMContextHandle
	{
		if (context.IsInvalid) throw new Exception("Invalid handle (GtkIMContextHandle)");
		GtkIMContextHandleExterns.gtk_im_context_focus_out(context);
		return context;
	}

/// <summary>
/// <para>
/// Retrieve the current preedit string for the input context,
/// and a list of attributes to apply to the string.
/// This string should be displayed inserted at the insertion
/// point.
/// </para>
/// </summary>

/// <param name="context">
/// a #GtkIMContext
/// </param>
/// <param name="str">
/// location to store the retrieved
///              string. The string retrieved must be freed with g_free().
/// </param>
/// <param name="attrs">
/// location to store the retrieved
///              attribute list.  When you are done with this list, you
///              must unreference it with pango_attr_list_unref().
/// </param>
/// <param name="cursor_pos">
/// location to store position of cursor (in characters)
///              within the preedit string.
/// </param>

	public static T GetPreeditString<T>(this T context, out string str, out MentorLake.Pango.PangoAttrListHandle attrs, out int cursor_pos) where T : GtkIMContextHandle
	{
		if (context.IsInvalid) throw new Exception("Invalid handle (GtkIMContextHandle)");
		GtkIMContextHandleExterns.gtk_im_context_get_preedit_string(context, out str, out attrs, out cursor_pos);
		return context;
	}

/// <summary>
/// <para>
/// Retrieves context around the insertion point. Input methods
/// typically want context in order to constrain input text based on
/// existing text; this is important for languages such as Thai where
/// only some sequences of characters are allowed.
/// </para>
/// <para>
/// This function is implemented by emitting the
/// GtkIMContext::retrieve_surrounding signal on the input method; in
/// response to this signal, a widget should provide as much context as
/// is available, up to an entire paragraph, by calling
/// gtk_im_context_set_surrounding(). Note that there is no obligation
/// for a widget to respond to the ::retrieve_surrounding signal, so input
/// methods must be prepared to function without context.
/// </para>
/// </summary>

/// <param name="context">
/// a #GtkIMContext
/// </param>
/// <param name="text">
/// location to store a UTF-8 encoded
///        string of text holding context around the insertion point.
///        If the function returns %TRUE, then you must free the result
///        stored in this location with g_free().
/// </param>
/// <param name="cursor_index">
/// location to store byte index of the insertion
///        cursor within @text.
/// </param>
/// <return>
/// %TRUE if surrounding text was provided; in this case
///    you must free the result stored in *text.
/// </return>

	public static bool GetSurrounding(this MentorLake.Gtk.GtkIMContextHandle context, out string text, out int cursor_index)
	{
		if (context.IsInvalid) throw new Exception("Invalid handle (GtkIMContextHandle)");
		return GtkIMContextHandleExterns.gtk_im_context_get_surrounding(context, out text, out cursor_index);
	}

/// <summary>
/// <para>
/// Notify the input method that a change such as a change in cursor
/// position has been made. This will typically cause the input
/// method to clear the preedit state.
/// </para>
/// </summary>

/// <param name="context">
/// a #GtkIMContext
/// </param>

	public static T Reset<T>(this T context) where T : GtkIMContextHandle
	{
		if (context.IsInvalid) throw new Exception("Invalid handle (GtkIMContextHandle)");
		GtkIMContextHandleExterns.gtk_im_context_reset(context);
		return context;
	}

/// <summary>
/// <para>
/// Set the client window for the input context; this is the
/// #GdkWindow in which the input appears. This window is
/// used in order to correctly position status windows, and may
/// also be used for purposes internal to the input method.
/// </para>
/// </summary>

/// <param name="context">
/// a #GtkIMContext
/// </param>
/// <param name="window">
/// the client window. This may be %NULL to indicate
///           that the previous client window no longer exists.
/// </param>

	public static T SetClientWindow<T>(this T context, MentorLake.Gdk.GdkWindowHandle window) where T : GtkIMContextHandle
	{
		if (context.IsInvalid) throw new Exception("Invalid handle (GtkIMContextHandle)");
		GtkIMContextHandleExterns.gtk_im_context_set_client_window(context, window);
		return context;
	}

/// <summary>
/// <para>
/// Notify the input method that a change in cursor
/// position has been made. The location is relative to the client
/// window.
/// </para>
/// </summary>

/// <param name="context">
/// a #GtkIMContext
/// </param>
/// <param name="area">
/// new location
/// </param>

	public static T SetCursorLocation<T>(this T context, MentorLake.Gdk.GdkRectangleHandle area) where T : GtkIMContextHandle
	{
		if (context.IsInvalid) throw new Exception("Invalid handle (GtkIMContextHandle)");
		GtkIMContextHandleExterns.gtk_im_context_set_cursor_location(context, area);
		return context;
	}

/// <summary>
/// <para>
/// Sets surrounding context around the insertion point and preedit
/// string. This function is expected to be called in response to the
/// GtkIMContext::retrieve_surrounding signal, and will likely have no
/// effect if called at other times.
/// </para>
/// </summary>

/// <param name="context">
/// a #GtkIMContext
/// </param>
/// <param name="text">
/// text surrounding the insertion point, as UTF-8.
///        the preedit string should not be included within
///        @text.
/// </param>
/// <param name="len">
/// the length of @text, or -1 if @text is nul-terminated
/// </param>
/// <param name="cursor_index">
/// the byte index of the insertion cursor within @text.
/// </param>

	public static T SetSurrounding<T>(this T context, string text, int len, int cursor_index) where T : GtkIMContextHandle
	{
		if (context.IsInvalid) throw new Exception("Invalid handle (GtkIMContextHandle)");
		GtkIMContextHandleExterns.gtk_im_context_set_surrounding(context, text, len, cursor_index);
		return context;
	}

/// <summary>
/// <para>
/// Sets whether the IM context should use the preedit string
/// to display feedback. If @use_preedit is FALSE (default
/// is TRUE), then the IM context may use some other method to display
/// feedback, such as displaying it in a child of the root window.
/// </para>
/// </summary>

/// <param name="context">
/// a #GtkIMContext
/// </param>
/// <param name="use_preedit">
/// whether the IM context should use the preedit string.
/// </param>

	public static T SetUsePreedit<T>(this T context, bool use_preedit) where T : GtkIMContextHandle
	{
		if (context.IsInvalid) throw new Exception("Invalid handle (GtkIMContextHandle)");
		GtkIMContextHandleExterns.gtk_im_context_set_use_preedit(context, use_preedit);
		return context;
	}

}

internal class GtkIMContextHandleExterns
{
	[DllImport(GtkLibrary.Name)]
	internal static extern bool gtk_im_context_delete_surrounding([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(DelegateSafeHandleMarshaller<MentorLake.Gtk.GtkIMContextHandle>))] MentorLake.Gtk.GtkIMContextHandle context, int offset, int n_chars);

	[DllImport(GtkLibrary.Name)]
	internal static extern bool gtk_im_context_filter_keypress([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(DelegateSafeHandleMarshaller<MentorLake.Gtk.GtkIMContextHandle>))] MentorLake.Gtk.GtkIMContextHandle context, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(DelegateSafeHandleMarshaller<MentorLake.Gdk.GdkEventKeyHandle>))] MentorLake.Gdk.GdkEventKeyHandle @event);

	[DllImport(GtkLibrary.Name)]
	internal static extern void gtk_im_context_focus_in([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(DelegateSafeHandleMarshaller<MentorLake.Gtk.GtkIMContextHandle>))] MentorLake.Gtk.GtkIMContextHandle context);

	[DllImport(GtkLibrary.Name)]
	internal static extern void gtk_im_context_focus_out([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(DelegateSafeHandleMarshaller<MentorLake.Gtk.GtkIMContextHandle>))] MentorLake.Gtk.GtkIMContextHandle context);

	[DllImport(GtkLibrary.Name)]
	internal static extern void gtk_im_context_get_preedit_string([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(DelegateSafeHandleMarshaller<MentorLake.Gtk.GtkIMContextHandle>))] MentorLake.Gtk.GtkIMContextHandle context, out string str, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(DelegateSafeHandleMarshaller<MentorLake.Pango.PangoAttrListHandle>))] out MentorLake.Pango.PangoAttrListHandle attrs, out int cursor_pos);

	[DllImport(GtkLibrary.Name)]
	internal static extern bool gtk_im_context_get_surrounding([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(DelegateSafeHandleMarshaller<MentorLake.Gtk.GtkIMContextHandle>))] MentorLake.Gtk.GtkIMContextHandle context, out string text, out int cursor_index);

	[DllImport(GtkLibrary.Name)]
	internal static extern void gtk_im_context_reset([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(DelegateSafeHandleMarshaller<MentorLake.Gtk.GtkIMContextHandle>))] MentorLake.Gtk.GtkIMContextHandle context);

	[DllImport(GtkLibrary.Name)]
	internal static extern void gtk_im_context_set_client_window([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(DelegateSafeHandleMarshaller<MentorLake.Gtk.GtkIMContextHandle>))] MentorLake.Gtk.GtkIMContextHandle context, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(DelegateSafeHandleMarshaller<MentorLake.Gdk.GdkWindowHandle>))] MentorLake.Gdk.GdkWindowHandle window);

	[DllImport(GtkLibrary.Name)]
	internal static extern void gtk_im_context_set_cursor_location([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(DelegateSafeHandleMarshaller<MentorLake.Gtk.GtkIMContextHandle>))] MentorLake.Gtk.GtkIMContextHandle context, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(DelegateSafeHandleMarshaller<MentorLake.Gdk.GdkRectangleHandle>))] MentorLake.Gdk.GdkRectangleHandle area);

	[DllImport(GtkLibrary.Name)]
	internal static extern void gtk_im_context_set_surrounding([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(DelegateSafeHandleMarshaller<MentorLake.Gtk.GtkIMContextHandle>))] MentorLake.Gtk.GtkIMContextHandle context, string text, int len, int cursor_index);

	[DllImport(GtkLibrary.Name)]
	internal static extern void gtk_im_context_set_use_preedit([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(DelegateSafeHandleMarshaller<MentorLake.Gtk.GtkIMContextHandle>))] MentorLake.Gtk.GtkIMContextHandle context, bool use_preedit);

}
